from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx import Document
import os
from math import floor, log2

WORKING_DIR = os.getcwd()
#using Pt(font.size)px as font size is way too small. Tweak this value to increase it.
_FONT_SCALING = 2


# full syntax: <link(href)text>
_LINK_KEYWORD = "<link"
_PLACEHOLDER_IMAGE = lambda x : f"__image_{x}__"

def _IMAGE_TEMPLATE(source : str, caption: str): return \
f"""
<figure>
    <div class="article-image">
        <img src='{source}' alt='some image lul u stupid' id='article_img'>
        <figcaption id='primary-image'>{caption}</figcaption>
    </div>
</figure>
"""

# list to keep track of indexes of tags to be replaced
__REPLACE__  = []



DEFAULT = {
    "font": "calibri",
    "fontsize": 11,
    "align": "left",
    "color": "#000000"
}

# these variables store how the generated html file surrounding its content looks like.
__BEGINFILE__ = """
{% extends "article.html" %}
{% block title %}{{ db_entry.title }}{% endblock %}
{% block article %}
"""
__ENDFILE__ = """
{% endblock %}
"""


"""
@param doc_source: word document as file or location
@return completely functional html file containing document content
"""
def convert(doc_source) -> str:
    return get_content_as_html(Document(doc_source))


"""
@param content: content of article in html form (without surroundings)
@return: fully functional and stand-alone html file of passed content
"""
def htmlify(content: str):
    return __BEGINFILE__ + content + __ENDFILE__

"""
@param html_text: pass text generated by get_content_as_html
@param num_images: the number of images to be inserted into the articles

@return: returns the text with image placeholders in place -> can be passed into fill_image_placeholders now
"""
def create_image_placeholders(html : str, num_images : int) -> str:
    tag = Tag()
    br = tag.linebreak()
    if html.count(br) <= num_images:
        for i in range(num_images):
            occ = html.find(br)
            #TODO spread remaining placeholders around articles
            if occ == -1: # if str.find() returns -1, the substring does not exist in parent string
                html += _PLACEHOLDER_IMAGE(i)
            else:
                # this essentially inserts the placeholder in between the entire string before and after the occurance
                html = html[:occ] + _PLACEHOLDER_IMAGE(i) + html[(occ + len(br)):]
        return html
    

"""
@param text: htmlifyed text with image placeholders in place
@param sources: a list of all image sources (gathered in cache in admin.py)

@return: parameter text with placeholders replaced through Tag.image 
    -> TODO replace with figure and correct id to make this integratable with articles.css
"""

# TODO rework:
# have get_placeholders_to_replace actually return something
# make the replacing independant of equal length of list
# just generally make this clean
def fill_image_placeholders(text: str, sources: list[str], captions: list[str]) -> str:
    tag = Tag()
    all_placeholders = create_placeholder_list(text)
    depth = floor(log2(len(sources)))

    # I don't know why that function doesn't return anything and instead works with a global list but it probably should
    # TODO one day rework this shit
    get_placeholders_to_replace(all_placeholders, num_to_replace=len(sources), depth=depth)
    to_replace = __REPLACE__.copy()
    to_replace.sort()
    __REPLACE__.clear()

    # OK SERIOUSLY WHAT IN THE GOOD HOLY MARMELADE FUCK AM I DOING HERE

    for src in enumerate(sources):
        text = text.replace(_PLACEHOLDER_IMAGE(src[0]), tag.article_image(src[1], captions[src[0]]))

    return text


"""
@param file_content: content of the file that will get checked for link syntax
@return: text given as parameter with the syntax for links replaced with the corresponding html

This has a bit of a bitter taste because it seems like this could and should be able to be done differently. However, this ultimately is what I went 
with, and is up for future work on this project to refactor. Basically what this funtion does: If someone wants to put links into their article, they
have to identify them in the word/text document as such through specific syntax. This function finds occurances of this syntax in the file content and
replaces them with their corresponding html tag.
"""
def replace_links(file_content: str) -> str:
    def get_link_tag(text, start_index):
        tag = ""
        i = start_index
        while text[i] != '>':
            tag += text[i]
            i += 1
        return tag + '>'

    def get_link_href(tag):
        href = ""
        i = len(_LINK_KEYWORD) + 1
        while tag[i] != ')':
            href += tag[i]
            i += 1
        return href

    def get_link_content(tag, href):
        return tag.replace(_LINK_KEYWORD, '').replace(f"({href})", '')[:-1]
    
    while _LINK_KEYWORD in file_content:
        tag = get_link_tag(file_content, file_content.find(_LINK_KEYWORD))
        href = get_link_href(tag)
        file_content = file_content.replace(tag, Tag.link(Tag, href, get_link_content(tag, href)))
    return file_content


"""
@param document: docx.document.Document
@return content of document converted to html

Converts a given word document into html to suit the means of the website. This means excluded are:
    images,
    links
Very basic CSS (text-align, font-size, font-family, color) is recognized.
I decided that since images in documents can't be recognized, the best workaround is to offer to put an image between every paragraph.
"""
def get_content_as_html(document) -> str:
    global DEFAULT

    HTML_CONTENT = ""
    tag = Tag()

    for paragraph in document.paragraphs:
        #stores the content of the current paragraph to pass on to Tag.paragraph(); is already html-formatted
        par_content = ""
        try:
            attr = {
                "font": get_font(paragraph.runs[0].font, handleNone=True),
                "fontsize": get_fontsize(paragraph.runs[0].font.size, handleNone=True),
                "align": get_textalign(paragraph.alignment, handleNone=True),
                "color": get_color(paragraph.runs[0].font.color.rgb.__str__())
            }

        except IndexError:
            attr["fontsize"] = DEFAULT["fontsize"]
            attr["font"] = DEFAULT["font"]
            attr["align"] = DEFAULT["align"]

            par_content = tag.linebreak()

        for run in paragraph.runs:
            font = run.font
            font_size = get_fontsize(font.size)
            # when only one word is coloured (without any additional decoration), it will not be detected as a run, so this is 
            # only effectiveto a certain extend, but still, I tried
            run_color = get_color(font.color.rgb.__str__())
            content = run.text

            #checking for text decorations and surrounding the content accordingly
            if font.italic: content = tag.italic(content, font=font.name, fontsize=font_size, color=run_color)
            if font.bold: content = tag.bold(content, font=font.name,fontsize=font_size, color=run_color)
            if font.underline: content = tag.underline(content, font=font.name, fontsize=font_size, color=run_color)

            if content == "":
                par_content += tag.linebreak()
            else:
                par_content += content
        par_content = tag.paragraph(par_content, font=attr["font"], fontsize=attr["fontsize"], textalign=attr["align"])
        HTML_CONTENT += f"{par_content}\n"

    return HTML_CONTENT


#--------------------------------------------------------------------------------------------------------------------------


# i don't know why i thought this little syntactic sugar was worth an entire own class
class Tag:
    def __init__(self):
        pass

    def header(self, hierarchy: int, content: str, style=()) -> str:
        pass

    #TODO put style definition into its own function
    def paragraph(self, content: str, font=None,  fontsize=None, textalign=None, color=None) -> str:
        style = " style='{0}{1}{2}{3}'".format(self.set_font(font), self.set_fontsize(fontsize),
                                               self.set_textalign(textalign), self.set_color(color))

        #if style looks like this, every style is the same as the default, making specifying it unecessary
        if style == " style=''":
            style = ""
        tag_open = "<p{}>".format(style)
        return "{0}{1}</p>".format(tag_open, content)

    def image(self, source: str) -> str:
        return "<img src='source' alt=''>"

    def link(self, href: str, content: str) -> str:
        return "<a href='{0}'>{1}</a>".format(href, content)

    def linebreak(self) -> str:
        return "<br>"

    def italic(self, content: str, font=None,  fontsize=None, textalign=None, color=None) -> str:
        style = " style='{0}{1}{2}'".format(self.set_font( font), self.set_fontsize(fontsize), self.set_color(color))
        if style == " style=''":
            style = ""
        tag_open = "<i{}>".format(style)
        return "{0}{1}</i>".format(tag_open, content)

    def bold(self, content: str, font=None,  fontsize=None, textalign=None, color=None) -> str:
        style = " style='{0}{1}{2}'".format(self.set_font(font), self.set_fontsize(fontsize), self.set_color(color))
        if style == " style=''":
            style = ""
        tag_open = "<b{}>".format(style)
        return "{0}{1}</b>".format(tag_open, content)

    def underline(self, content: str, font=None,  fontsize=None, textalign=None, color=None) -> str:
        style = " style='{0}{1}{2}'".format(self.set_font(font), self.set_fontsize(fontsize), self.set_color(color))
        if style == " style=''":
            style = ""
        tag_open = "<u{}>".format(style)
        return "{0}{1}</u>".format(tag_open, content)

    #--------------------------------------------------
    #absolutely necessary functions

    def set_font(self, font: str) -> str:
        if not font:
            return ""
        return "font-family: {};".format(font)

    def set_fontsize(self, size: int) -> str:
        if not size:
            return ""
        return "font-size: {}px;".format(size * _FONT_SCALING)

    def set_textalign(self, align: str) -> str:
        if not align:
            return ""
        return "text-align: {};".format(align)

    def set_color(self, color: str) -> str:
        if not color:
            return ""
        return "color: {};".format(color)

    def tab():
        return "&#9"

    #-----------------------------------------------------------------------------
    #really necessary function for integration to website
    # actually the entire stuff of relevance is written at the top of the file lol
    def article_image(source: str, caption: str) -> str:
        return _IMAGE_TEMPLATE(source, caption)


#--------------------------------------------------------------------------------------------------------------------------

"""
@return: text alignment formatted as CSS
"""
def get_textalign(alignment: WD_ALIGN_PARAGRAPH, default=DEFAULT["align"], handleNone=False) -> str:
    if alignment == WD_ALIGN_PARAGRAPH.CENTER: return "center"
    if alignment == WD_ALIGN_PARAGRAPH.LEFT: return "left"
    if alignment == WD_ALIGN_PARAGRAPH.RIGHT: return "right"
    if handleNone: return default
    return None


def get_font(font, default=DEFAULT["font"], handleNone=False) -> str:
    if not font.name:
        if handleNone:
            return default
        return None
    return font.name.lower()


"""
@param size: run.font.size
@param default: size of the run befor, in case run.font.size is None

run.font.size returns a very high number -> Pt(font.size) returns actual font-size
"""
def get_fontsize(size: int, default=DEFAULT["fontsize"], handleNone=False) -> int:
    if not size:
        if handleNone:
            return default
        return None
    for i in range(64):
        if size == Pt(i):
            return i
    return None


"""
@return color as hex code, if color is None, the default is used
"""
def get_color(hex: str, default=DEFAULT["color"]) -> str:
    if not hex or hex == "None":  # for some reason `font.color.rgb.__str__()` returns "None" instead of actual None
        return default
    return "#{}".format(hex)



#----------------------------------------------------------------------------------------------------------------------------------

def create_placeholder_list(text: str) -> list[int]:
    counter = 0
    placeholders = []
    while _PLACEHOLDER_IMAGE(counter) in text:
        placeholders.append(counter)
        counter += 1
    return placeholders

"""

@return middle: the index of the list's middle
@return list[middle]: the value of that middle
"""
def find_middle(list, /, round=round) -> tuple:
    if len(list) == 1:
        return (0, list[0])
    if len(list) == 0:
        return None
    length = len(list) - 1
    middle = round(length / 2)
    return (middle, list[middle])


"""
Places images on placeholders as evenly as possible. This is achieved through treating the (sorted) list of placeholders similar to a Binary Tree:
    1. The middle of the list of placeholders is selected and appended to a global list keeping track of all positions to be replaced.
    2. The list is split at this middle index, creating two new lists ("sub-trees")
    3. Each of those is recursively passed into the function and the process gets repeated

NOTE: This solution does have some issues. For example, when there's 2 images to be placed, it only calls the recursive function on the first sub-
list, making the result look something like `[replaced, 1, replaced, 2, 3]`, unevening the positioning. 
TODO: this could probably be handled with another gatekeeper statement 
    OR      by only saving the middle of the list if its length is uneven or 2

@param placeholders: All placeholder occurances in a text passed as a list
@param num TODO rename : the number of images to place in the text
@param depth: Used to determine the maximum recursion depth. Essentially this keeps the function from calling itself repeatadly on the first sublist
and never getting to fill up its second half
    (the depth is defined as `floor(log2(num_images))`, this has to do with splitting the list in two, thus doubling the total number of lists 
    per recursion call and thus leading to a rise in sublists of the type 2**x)
"""
def get_placeholders_to_replace(placeholders: list, num_to_replace: int, depth) -> None:
    if len(__REPLACE__) >= num_to_replace:  # all images have found a place to be put in
        return
    if len(placeholders) < 1:  # the passed list is empty
        return
    # reached the maximum depth (is required in order to evenly spread the images among the articles)
    if depth < 0:
        return
    middle = find_middle(placeholders)
    __REPLACE__.append(middle[1])
    first_half = placeholders[:middle[0]]
    second_half = placeholders[(middle[0] + 1):]

    get_placeholders_to_replace(first_half, num_to_replace=num_to_replace, depth=depth-1)
    get_placeholders_to_replace(second_half, num_to_replace=num_to_replace, depth=depth-1)

#----------------------------------------------------------------------------------------------------------------------------------
